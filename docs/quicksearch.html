<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" DocStrap Classes HandleInclude Classes Classes Handle Include × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-08-04T16:13:03+08:00 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" DocStrap Classes HandleInclude Handle.jsHandle.js，一个基于 koa 和 sequelize 的中间库，让你只专注于接口逻辑。 文档（暂无计划） 但是，你可以访问由 jsdoc 生成的 api 文档。 × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-08-04T16:13:03+08:00 using the DocStrap template. "},"Handle.html":{"id":"Handle.html","title":"Class: Handle","body":" DocStrap Classes HandleInclude Class: Handle Handle Handle.js， 一个基于 koa 和 sequelize 的中间库, 让你只专注于接口逻辑。 new Handle(model [, options]) Parameters: Name Type Argument Default Description model Model sequelize 的模型实例 options object &lt;optional&gt; {} 选项对象 Properties Name Type Argument Default Description mock Mock &lt;optional&gt; null mock 库，以启用 Handle.prototype.mock 方法 before(data, ctx, next) function &lt;optional&gt; 全局钩子。before 钩子在数据库操作之前执行。（注意，全局钩子 before 与快捷方法的 before 函数行为一致，但 before 函数在 全局钩子 before 之后调用，可能会发生覆盖。） after(result, ctx, next) function &lt;optional&gt; 全局钩子。 after 钩子在数据库操作之后执行（注意，情况和全局钩子 before 相同） data(err, data, ctx, next) function &lt;optional&gt; 全局钩子。data 钩子可以在返回数据到前端之前和捕获异常之后做一些处理。 Extends Base Members &lt;static&gt; Include :Include 关联生成器 Type: Include Since: 1.0.0 See: Include Methods defaultScope(scopes) 组合一个或多个实例作用域（作用于实例的每个方法） Parameters: Name Type Argument Description scopes object | function &lt;repeatable&gt; 作用域 Since: 1.0.0 See: scope rawScope Returns: Type Handle mock(rule) 向数据库中批量插入由 mock 生成的随机数据 Parameters: Name Type Description rule object mock 的生成规则 Since: 1.0.0 Returns: Type * Example // 生成 10 条数据（mockjs 为例） h.mock({ 'data|10': [ { title: '@ctitle', content: '@cparagraph', } ] }) process( [method], f(data,ctx,next)) 开始一个过程流程，并结合过程方法（raw*）提供更灵活的空间。 过程的流程处在【获取前端数据】与【返回数据到前端】之间, 过程方法（以 raw 开头的模型方法）专门为过程流程而生， 它不同于快捷方法，过程方法返回从数据库来的数据，并由你决定如何处理。 很合适数据验证、过滤和对数据库多次操作的场景。 全局钩子的行为发生了一些变化，在整个过程流程中只会执行一次。 （注意，流程结束时，必须 return 出返回前端的数据） Parameters: Name Type Argument Default Description method string &lt;optional&gt; 'get' 请求方法 f(data,ctx,next) asyncFunction 一个 async/await 函数 Since: 1.0.0 Returns: Type function rawScope(scopeNames) 组合一个或多个 sequelize 作用域（一层简单的封装） Parameters: Name Type Argument Description scopeNames object | function &lt;repeatable&gt; 要组合的作用域名 Since: 1.0.0 See: defaultScope scope Returns: Type Handle scope(scopes) 组合一个或多个方法作用域（仅作用于接下来第一次使用的方法） Parameters: Name Type Argument Description scopes object | function &lt;repeatable&gt; 作用域 Since: 1.0.0 See: defaultScope rawScope Returns: Type Handle toggle() TODO: 需重写 transaction() TODO: 未实现（事务） × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-08-04T16:13:03+08:00 using the DocStrap template. "},"Include.html":{"id":"Include.html","title":"Class: Include","body":" DocStrap Classes HandleInclude Class: Include Include 关联查询的辅助类， 通过 add 添加模型的基本 include，然后由 create 指定层级关系，并生成复杂的关联查询。 new Include() Methods add(name, f) 添加一个 include Parameters: Name Type Description name string include 的名称 f object | function 一个返回 include 数据的方法，如果为对象，则简单的封装成一个函数 Returns: Type Include create(scopes) 组合 include 生成更复杂的 include Parameters: Name Type Argument Description scopes args &lt;repeatable&gt; 指定的层级关系 Returns: Type Array get(name) 获取一个 include Parameters: Name Type Description name string include 的名称 Returns: Type * remove(name) 移除一个 include Parameters: Name Type Description name string include 的名称 Returns: Type boolean × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-08-04T16:13:03+08:00 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
